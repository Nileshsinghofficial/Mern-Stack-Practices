<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Mastery Guide 2025 â€“ The Ultimate Edition</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            color: #212529;
        }
        .container {
            max-width: 850px;
            margin: 40px auto;
            padding: 25px 45px;
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        h1, h2, h3, h4 {
            font-weight: 700;
            color: #1a1a1a;
            margin-top: 1.6em;
            margin-bottom: 0.8em;
            line-height: 1.3;
        }
        h1 {
            font-size: 2.5em;
            text-align: center;
            color: #0056b3;
            border-bottom: 3px solid #0056b3;
            padding-bottom: 15px;
            margin-bottom: 1em;
        }
        .intro {
            font-style: italic;
            color: #555;
            text-align: center;
            margin-bottom: 2.5em;
            font-size: 1.1em;
        }
        h2 {
            font-size: 2em;
            color: #343a40;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 8px;
        }
        h3 {
            font-size: 1.5em;
            color: #495057;
        }
        h4 {
            font-size: 1.2em;
            color: #007BFF;
        }
        p {
            margin-bottom: 1.1em;
        }
        strong, b {
            font-weight: 600;
        }
        ul {
            padding-left: 25px;
        }
        li {
            margin-bottom: 0.6em;
        }
        pre {
            background-color: #f1f3f5;
            border: 1px solid #ced4da;
            border-radius: 6px;
            padding: 16px;
            overflow-x: auto;
            font-size: 0.95em;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre code {
            border: none;
            background: none;
            padding: 0;
        }
        code:not(pre > code) {
            background-color: #e9ecef;
            color: #c92a2a;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .interview-qa {
            margin-top: 1.5em;
            padding: 10px 15px;
            border-left: 4px solid #007BFF;
            background-color: #f8f9fa;
            border-radius: 0 4px 4px 0;
        }
        .interview-qa strong {
            display: block;
            margin-bottom: 0.5em;
            color: #343a40;
        }
        .output {
            font-size: 0.9em;
            font-style: italic;
            color: #555;
            border-left: 3px solid #6c757d;
            padding-left: 15px;
            margin-top: -10px;
            background-color: #f8f9fa;
        }
        .key-points {
            background-color: #e6f7ff;
            border: 1px solid #91d5ff;
            border-radius: 5px;
            padding: 15px 20px;
        }
        @media print {
            body {
                background-color: #fff;
            }
            .container {
                box-shadow: none;
                border: none;
                margin: 0;
                max-width: 100%;
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>JS Mastery Guide 2025</h1>
        <p class="intro">The Ultimate Edition. A truly comprehensive handbook covering every essential JavaScript concept with detailed explanations, multiple examples, key summaries, and exhaustive interview questions.</p>

        <h2>1. Variables & Scope</h2>
        <h3>Definition</h3>
        <p>Variables are containers for storing data values. Scope determines the accessibility (visibility) of these variables. JavaScript has three types of scope: Global Scope, Function Scope, and Block Scope.</p>
        <div class="key-points">
            <h4>Key Points / Cheatsheet</h4>
            <ul>
                <li><code>var</code>: Function-scoped, hoisted and initialized with <code>undefined</code>. Can be re-declared and updated. Avoid in modern JS.</li>
                <li><code>let</code>: Block-scoped, hoisted but not initialized (Temporal Dead Zone). Can be updated but not re-declared in the same scope.</li>
                <li><code>const</code>: Block-scoped, hoisted but not initialized (TDZ). Cannot be updated or re-declared. For objects/arrays, the reference is constant, not the content.</li>
                <li><strong>Scope Chain:</strong> If a variable isn't found in the current scope, the engine looks at the outer scope, and so on, up to the global scope.</li>
            </ul>
        </div>
        <h3>Syntax & Subtopics</h3>
        <h4>A. <code>var</code> (Function Scope)</h4>
        <p>Variables declared with <code>var</code> are accessible anywhere within the function they are defined in.</p>
        <strong>Example 1: Function Scope</strong>
        <pre><code>function testVar() {
  if (true) {
    var x = 10;
    console.log("Inside block:", x); // Inside block: 10
  }
  console.log("Outside block:", x); // Outside block: 10
}
testVar();
// console.log(x); // ReferenceError: x is not defined
</code></pre>
        <strong>Example 2: Hoisting with <code>var</code></strong>
        <pre><code>console.log(myVar); // undefined
var myVar = "Hello";
console.log(myVar); // "Hello"
</code></pre>

        <h4>B. <code>let</code> (Block Scope)</h4>
        <p>Variables declared with <code>let</code> are confined to the block (<code>{}</code>) in which they are defined.</p>
        <strong>Example 1: Block Scope</strong>
        <pre><code>function testLet() {
  let y = 20;
  if (true) {
    let z = 30;
    console.log("Inside block:", z); // Inside block: 30
    console.log("Accessing y from inside:", y); // Accessing y from inside: 20
  }
  // console.log(z); // ReferenceError: z is not defined
}
testLet();
</code></pre>
        <strong>Example 2: Temporal Dead Zone (TDZ)</strong>
        <pre><code>// console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
let myLet = "World";
</code></pre>

        <h4>C. <code>const</code> (Block Scope & Immutable Reference)</h4>
        <p><code>const</code> is like <code>let</code> but the variable's value cannot be reassigned.</p>
        <strong>Example 1: Reassignment Error</strong>
        <pre><code>const PI = 3.14;
// PI = 3.14159; // TypeError: Assignment to constant variable.
</code></pre>
        <strong>Example 2: Mutating an Object</strong>
        <pre><code>const person = { name: "Alice" };
console.log(person.name); // "Alice"

// This is allowed because we are changing the object's content, not its reference.
person.name = "Bob";
console.log(person.name); // "Bob"

// This is NOT allowed.
// person = { name: "Charlie" }; // TypeError
</code></pre>

        <h3>Possible Interview Questions & Answers</h3>
        <div class="interview-qa"><strong>What is the difference between <code>var</code>, <code>let</code>, and <code>const</code>?</strong><p><strong>Answer:</strong> <code>var</code> is function-scoped and hoisted with an initial value of <code>undefined</code>. <code>let</code> and <code>const</code> are block-scoped and are hoisted but not initialized, leading to a Temporal Dead Zone (TDZ). <code>let</code> can be reassigned, while <code>const</code> cannot.</p></div>
        <div class="interview-qa"><strong>What is the Temporal Dead Zone (TDZ)?</strong><p><strong>Answer:</strong> The TDZ is the period between entering a scope and the point where a <code>let</code> or <code>const</code> variable is declared. During this time, the variable exists but cannot be accessed. Accessing it results in a <code>ReferenceError</code>.</p></div>
        <div class="interview-qa"><strong>What is the difference between `Object.freeze()` and `const`?</strong><p><strong>Answer:</strong> `const` makes the variable reference immutable, meaning you cannot reassign the variable to a new value. However, if the variable is an object or array, its contents can still be mutated. `Object.freeze()` makes the properties of an object immutable, preventing any changes to the object's contents. It provides deeper immutability than `const`.</p></div>
        <div class="interview-qa"><strong>What is an IIFE and what problem did it solve?</strong><p><strong>Answer:</strong> An IIFE (Immediately Invoked Function Expression) is a function that is defined and executed right away. Before <code>let</code> and <code>const</code> introduced block scope, IIFEs were the primary way to create a private scope for variables, preventing them from polluting the global namespace.</p></div>
        
        <h2>2. Data Types & Type Coercion</h2>
        <h3>Definition</h3>
        <p>JavaScript has a set of data types that define the kind of values a variable can hold. It is a dynamically typed language, meaning you don't need to specify the type of a variable. Type Coercion is the automatic conversion of values from one data type to another.</p>
        <div class="key-points">
            <h4>Key Points / Cheatsheet</h4>
            <ul>
                <li><strong>Primitive Types (7):</strong> <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>, <code>bigint</code>. Primitives are immutable.</li>
                <li><strong>Object Type (1):</strong> <code>object</code>. Includes arrays, functions, and plain objects. Objects are mutable.</li>
                <li><strong>Type Coercion:</strong> Happens automatically with operators like <code>+</code>, <code>-</code>, <code>==</code>.</li>
                <li><strong>Strict Equality (<code>===</code>):</strong> Compares value and type. No coercion. Always preferred.</li>
                <li><strong>Loose Equality (<code>==</code>):</strong> Compares value after coercing types. Can lead to unexpected results. Avoid.</li>
            </ul>
        </div>
        <h3>Syntax & Subtopics</h3>
        <h4>A. Primitive Types</h4>
        <p>Primitives are passed by value.</p>
        <strong>Example 1: Immutability of Strings</strong>
        <pre><code>let myString = "hello";
myString.toUpperCase(); // Creates a new string "HELLO"
console.log(myString); // "hello" (The original is unchanged)

myString = myString.toUpperCase(); // Reassignment
console.log(myString); // "HELLO"
</code></pre>
        <strong>Example 2: `null` vs. `undefined`</strong>
        <pre><code>let a;
console.log(a); // undefined (hasn't been assigned a value)

let b = null;
console.log(b); // null (has been explicitly assigned a value of nothing)

console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object" (This is a famous, long-standing bug in JS)
</code></pre>
        
        <h4>B. Object Type</h4>
        <p>Objects are passed by reference.</p>
        <strong>Example 1: Passed by Reference</strong>
        <pre><code>let obj1 = { name: "Alice" };
let obj2 = obj1; // obj2 points to the same object in memory

obj2.name = "Bob";

console.log(obj1.name); // "Bob" (obj1 was also changed)
</code></pre>

        <h4>C. Type Coercion</h4>
        <p>JavaScript's engine will try to "help" by converting types when using certain operators.</p>
        <strong>Example 1: Loose Equality (<code>==</code>)</strong>
        <pre><code>console.log(5 == "5");       // true (string "5" is coerced to number 5)
console.log(true == 1);        // true (boolean true is coerced to number 1)
console.log(null == undefined); // true (a special case)
</code></pre>
        <strong>Example 2: Strict Equality (<code>===</code>)</strong>
        <pre><code>console.log(5 === "5");      // false (different types)
console.log(true === 1);       // false (different types)
console.log(null === undefined); // false (different types)
</code></pre>

        <h3>Possible Interview Questions & Answers</h3>
        <div class="interview-qa"><strong>What is the difference between `null` and `undefined`?</strong><p><strong>Answer:</strong> `undefined` typically means a variable has been declared but not yet assigned a value. `null` is an assignment value that represents the intentional absence of any object value.</p></div>
        <div class="interview-qa"><strong>What is the output of `typeof null` and why?</strong><p><strong>Answer:</strong> The output is <code>"object"</code>. This is a historical bug in the first version of JavaScript that has been preserved for backward compatibility. It should technically be <code>"null"</code>.</p></div>
        <div class="interview-qa"><strong>Explain truthy and falsy values in JavaScript. Give examples.</strong><p><strong>Answer:</strong> A "falsy" value is a value that is considered `false` when encountered in a Boolean context (like an `if` statement). The falsy values are: <code>false</code>, <code>0</code>, <code>-0</code>, <code>0n</code> (BigInt zero), <code>""</code> (empty string), <code>null</code>, <code>undefined</code>, and <code>NaN</code>. All other values are "truthy," including <code>"0"</code>, <code>"false"</code>, <code>[]</code>, and <code>{}</code>.</p></div>
        <div class="interview-qa"><strong>What is the difference between `==` and `===`? Which should you use?</strong><p><strong>Answer:</strong> `==` (loose equality) compares two values for equality after performing type coercion if necessary. `===` (strict equality) compares both the value and the type, without coercion. You should almost always use `===` to avoid unexpected bugs from type coercion.</p></div>
        
        <h2>27. Performance: Debouncing and Throttling</h2>
        <h3>Definition</h3>
        <p><strong>Debouncing</strong> and <strong>Throttling</strong> are two techniques to control how often a function is executed, which is critical for performance in response to frequent events like scrolling, resizing, or typing.</p>
        <div class="key-points">
            <h4>Key Points / Cheatsheet</h4>
            <ul>
                <li><strong>Debouncing:</strong> Groups a burst of sequential calls into a single one. The function is only called after a specified period of **inactivity**.</li>
                <li><strong>Use Case for Debounce:</strong> Autocomplete search bars, form validation as the user types. The goal is to act only when the user has "finished" their action.</li>
                <li><strong>Throttling:</strong> Ensures a function is called at most once per specified period, regardless of how many times the event fires.</li>
                <li><strong>Use Case for Throttle:</strong> Limiting API calls on infinite scroll, tracking mouse movement, handling window resize events. The goal is to get regular updates without overwhelming the system.</li>
            </ul>
        </div>
        <h3>Syntax & Subtopics</h3>
        <h4>A. Debouncing</h4>
        <p>Waits for a pause in events before executing.</p>
        <strong>Example 1: Implementing a Basic Debounce</strong>
        <pre><code>function debounce(func, delay) {
  let timeoutId;
  // This is the returned function that will be called on every event
  return function(...args) {
    // Clear the previous timeout to reset the timer
    clearTimeout(timeoutId);
    // Set a new timeout
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Usage with a search input
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce((event) => {
  console.log(`Searching for: ${event.target.value}`);
}, 500)); // Only search 500ms after the user stops typing
</code></pre>

        <h4>B. Throttling</h4>
        <p>Executes the function at regular intervals.</p>
        <strong>Example 1: Implementing a Basic Throttle</strong>
        <pre><code>function throttle(func, limit) {
  let inThrottle = false;
  return function(...args) {
    if (!inThrottle) {
      // Execute the function
      func.apply(this, args);
      // Set the throttle flag
      inThrottle = true;
      // After the limit, reset the flag
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

// Usage with a scroll event
window.addEventListener('scroll', throttle(() => {
  console.log('Fetching more data...');
}, 1000)); // Will only log at most once per second
</code></pre>

        <h3>Possible Interview Questions & Answers</h3>
        <div class="interview-qa"><strong>Explain the difference between debouncing and throttling with a real-world analogy.</strong><p><strong>Answer:</strong> An elevator analogy works well. <strong>Throttling</strong> is like pressing the "close door" button; it only works once every few seconds, no matter how much you press it. <strong>Debouncing</strong> is like the elevator waiting 3 seconds *after the last person has entered* before closing the doors; if another person enters, the timer resets.</p></div>
        <div class="interview-qa"><strong>Which technique would you use for an "infinite scroll" feature and why?</strong><p><strong>Answer:</strong> You would use <strong>throttling</strong>. As the user scrolls, you want to check their position periodically (e.g., every 200ms) to load more content. Debouncing would only trigger after the user *stops* scrolling, defeating the purpose.</p></div>
        <div class="interview-qa"><strong>Which technique would you use for a search bar's autocomplete feature?</strong><p><strong>Answer:</strong> You would use <strong>debouncing</strong>. You don't want to send an API request for every single keystroke. Instead, you wait until the user has stopped typing for a brief moment (e.g., 300ms) and then send a single request with their complete query.</p></div>
        <div class="interview-qa"><strong>What is `requestAnimationFrame` and how does it relate to throttling?</strong><p><strong>Answer:</strong> `requestAnimationFrame` is a browser API that tells the browser you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. It's a highly optimized form of throttling that is synced with the browser's display refresh rate (typically 60fps). It's the best choice for performance-critical animations or scroll handlers that involve changing the DOM.</p></div>
    </div>
</body>
</html>